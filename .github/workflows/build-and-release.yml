name: Build + Release

on:
  workflow_dispatch:
    inputs:
      upstream_version:
        description: "Upstream Stable version (leave blank to auto-detect from CfT)"
        required: false
        type: string
  push:
    branches: [main]
    paths:
      - 'patches/**'
      - 'scripts/**'
      - '.github/workflows/build-and-release.yml'

permissions:
  contents: write


jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.resolve.outputs.tag }}
      upstream_version: ${{ steps.resolve.outputs.upstream_version }}
    steps:
      - uses: actions/checkout@v4

      - name: Resolve version and compute release tag
        id: resolve
        run: |
          set -euo pipefail
          v="${{ inputs.upstream_version }}"
          if [ -z "$v" ]; then
            echo "Auto-detecting upstream Stable version from CfT..."
            v="$(curl -fsSL \
              "https://googlechromelabs.github.io/chrome-for-testing/last-known-good-versions.json" \
              | jq -r '.channels.Stable.version')"
          fi
          short="$(git rev-parse --short HEAD)"
          # Build number = DDHHMM in UTC so newer builds always sort higher
          build_num="$(date -u +'%d%H%M')"
          tag="${v}+cloakium-${build_num}-${short}"
          echo "upstream_version=$v" >> "$GITHUB_OUTPUT"
          echo "tag=$tag" >> "$GITHUB_OUTPUT"
          echo "Upstream: $v"
          echo "Build:    $build_num"
          echo "Cloakium: $short"
          echo "Tag:      $tag"

  ensure-release:
    needs: prepare
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Create GitHub Release if missing
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          tag="${{ needs.prepare.outputs.tag }}"
          upstream="${{ needs.prepare.outputs.upstream_version }}"
          if gh release view "$tag" --repo "$GITHUB_REPOSITORY" >/dev/null 2>&1; then
            echo "Release $tag already exists."
            exit 0
          fi
          gh release create "$tag" \
            --repo "$GITHUB_REPOSITORY" \
            --title "$tag" \
            --notes "Cloakium build based on upstream Chrome Stable $upstream (CfT last-known-good)."

  build:
    needs: [prepare, ensure-release]
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: linux-amd64
            runner: [self-hosted, linux, x64]
            asset: cloakium-linux-amd64.tar.zst
            target_os: linux
            target_cpu: x64
            cross: false
            ephemeral: false
            cache_root: /cache
            work_root: /work

          - target: darwin-arm64
            runner: [self-hosted, macOS, ARM64]
            asset: cloakium-darwin-arm64.zip
            target_os: mac
            target_cpu: arm64
            cross: false
            ephemeral: false
            cache_root: ~/.github-runner-cache
            work_root: ~/.github-runner-work

    runs-on: ${{ matrix.runner }}
    timeout-minutes: 360

    env:
      CACHE_ROOT: ${{ matrix.cache_root }}
      WORK_ROOT: ${{ matrix.work_root }}

    steps:
      - uses: actions/checkout@v4

      - name: Check if asset already exists
        id: check-asset
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          set -euo pipefail
          tag="${{ needs.prepare.outputs.tag }}"
          asset="${{ matrix.asset }}"

          # Use curl (always available) instead of gh (missing on some runners)
          assets="$(curl -fsSL \
            -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$GITHUB_REPOSITORY/releases/tags/$tag" \
            2>/dev/null | python3 -c "
          import sys, json
          for a in json.load(sys.stdin).get('assets', []):
              print(a['name'])
          " 2>/dev/null || true)"

          if echo "$assets" | grep -qx "$asset"; then
            echo "Asset $asset already exists on release $tag — skipping build"
            echo "skip=true" >> "$GITHUB_OUTPUT"
          else
            echo "Asset $asset not found — proceeding with build"
            echo "skip=false" >> "$GITHUB_OUTPUT"
          fi

      # --- Ephemeral-only steps (Blacksmith / cloud runners) ---

      - name: Free disk space
        if: steps.check-asset.outputs.skip == 'false' && matrix.ephemeral && runner.os == 'Linux'
        shell: bash
        run: |
          sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc \
            /usr/local/share/boost /usr/share/swift /opt/hostedtoolcache
          docker system prune -af 2>/dev/null || true
          sudo apt-get clean
          echo "Free space: $(df -h / | tail -1 | awk '{print $4}')"

      - name: Install build dependencies
        if: steps.check-asset.outputs.skip == 'false' && matrix.ephemeral && runner.os == 'Linux'
        shell: bash
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            build-essential clang lld llvm \
            python3 python3-pip python3-setuptools \
            pkg-config libglib2.0-dev libgtk-3-dev libnss3-dev \
            libatk1.0-dev libatk-bridge2.0-dev libcups2-dev \
            libxcomposite-dev libxdamage-dev libxrandr-dev \
            libgbm-dev libpango1.0-dev libasound2-dev \
            libdrm-dev libxshmfence-dev \
            gperf libffi-dev libxkbcommon-dev \
            zip zstd pv

      - name: Verify MinIO cache connectivity
        if: steps.check-asset.outputs.skip == 'false' && matrix.ephemeral
        env:
          CACHE_ENDPOINT: ${{ secrets.CACHE_ENDPOINT }}
          CACHE_ACCESS_KEY: ${{ secrets.CACHE_ACCESS_KEY }}
          CACHE_SECRET_KEY: ${{ secrets.CACHE_SECRET_KEY }}
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${CACHE_ENDPOINT:-}" ]; then
            echo "::warning::CACHE_ENDPOINT not set — skipping cache upload later"
            echo "CACHE_OK=false" >> "$GITHUB_ENV"
            exit 0
          fi

          # Install mc (MinIO client)
          sudo curl -fsSL https://dl.min.io/client/mc/release/linux-amd64/mc -o /usr/local/bin/mc
          sudo chmod +x /usr/local/bin/mc
          mc alias set cache "$CACHE_ENDPOINT" "$CACHE_ACCESS_KEY" "$CACHE_SECRET_KEY"

          # Ensure bucket exists
          mc mb --ignore-existing cache/cloakium-cache

          # Round-trip test: write, read, delete
          echo "connectivity-check-$(date +%s)" > /tmp/cache-test.txt
          mc cp /tmp/cache-test.txt cache/cloakium-cache/_test_probe
          mc cat cache/cloakium-cache/_test_probe > /tmp/cache-verify.txt
          if ! diff -q /tmp/cache-test.txt /tmp/cache-verify.txt; then
            echo "::error::MinIO round-trip failed — data mismatch"
            exit 1
          fi
          mc rm cache/cloakium-cache/_test_probe
          rm -f /tmp/cache-test.txt /tmp/cache-verify.txt

          echo "MinIO connectivity verified."
          echo "CACHE_OK=true" >> "$GITHUB_ENV"

      # --- Common steps ---

      - name: Resolve paths
        if: steps.check-asset.outputs.skip == 'false'
        shell: bash
        run: |
          # Expand ~ to actual home dir for macOS runners
          CACHE_ROOT="${CACHE_ROOT/#\~/$HOME}"
          WORK_ROOT="${WORK_ROOT/#\~/$HOME}"
          echo "CACHE_ROOT=$CACHE_ROOT" >> "$GITHUB_ENV"
          echo "WORK_ROOT=$WORK_ROOT" >> "$GITHUB_ENV"
          echo "CHROMIUM_SRC=$WORK_ROOT/chromium/src" >> "$GITHUB_ENV"
          mkdir -p "$CACHE_ROOT" "$WORK_ROOT"

      - name: Ensure Metal toolchain (macOS)
        if: steps.check-asset.outputs.skip == 'false' && runner.os == 'macOS'
        shell: bash
        run: |
          # ANGLE Metal shaders require the Metal toolchain
          if ! xcrun -f metal &>/dev/null; then
            echo "Installing Metal toolchain..."
            xcodebuild -downloadComponent MetalToolchain
          else
            echo "Metal toolchain already available"
          fi

      - name: Set up depot_tools
        if: steps.check-asset.outputs.skip == 'false'
        shell: bash
        run: |
          set -euo pipefail
          if [ ! -d "$CACHE_ROOT/depot_tools" ]; then
            git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git \
              "$CACHE_ROOT/depot_tools"
          else
            git -C "$CACHE_ROOT/depot_tools" pull --ff-only || true
          fi
          echo "$CACHE_ROOT/depot_tools" >> "$GITHUB_PATH"

      - name: Sync Chromium source
        if: steps.check-asset.outputs.skip == 'false'
        shell: bash
        env:
          UPSTREAM_VERSION: ${{ needs.prepare.outputs.upstream_version }}
        run: |
          set -euo pipefail
          WORK="$WORK_ROOT/chromium"

          write_gclient() {
            mkdir -p "$WORK"
            cat > "$WORK/.gclient" << GCEOF
          solutions = [{
            "name": "src",
            "url": "https://chromium.googlesource.com/chromium/src.git@$UPSTREAM_VERSION",
            "managed": False,
            "custom_deps": {},
            "custom_vars": {
              "checkout_pgo_profiles": True,
            },
          }]
          GCEOF
          }

          # Always (re)create .gclient to ensure latest settings
          write_gclient

          cd "$WORK"

          # Force fetch + reset so persistent runners actually switch versions
          if [ -d "$WORK/src/.git" ]; then
            echo "Existing checkout found — fetching tag $UPSTREAM_VERSION..."
            git -C "$WORK/src" fetch --depth=1 origin "refs/tags/$UPSTREAM_VERSION:refs/tags/$UPSTREAM_VERSION" 2>/dev/null || true
          fi

          gclient sync --shallow --no-history --force --reset -D \
            || {
              if [ "${{ matrix.ephemeral }}" = "true" ]; then
                echo "Sync failed — nuking src/ and retrying from scratch..."
                rm -rf "$WORK/src"
                write_gclient
                gclient sync --shallow --no-history --force --reset -D
              else
                echo "Sync failed on persistent runner — NOT nuking src/ (would destroy build cache)"
                echo "Check git safe.directory settings and ownership of $WORK/src"
                exit 1
              fi
            }

          # Verify checkout matches requested version
          actual="$(git -C "$WORK/src" describe --tags --always 2>/dev/null || git -C "$WORK/src" log -1 --format=%s)"
          echo "Sync complete. Source at: $WORK/src"
          echo "Requested: $UPSTREAM_VERSION"
          echo "Actual HEAD: $actual"
          if ! git -C "$WORK/src" log -1 --format=%H | xargs git -C "$WORK/src" branch -r --contains 2>/dev/null | grep -q "$UPSTREAM_VERSION"; then
            echo "::warning::HEAD may not match requested version $UPSTREAM_VERSION — verify build output"
          fi

      # --- Self-hosted only: seed build output from MinIO (first run) ---

      - name: Seed build output from MinIO
        if: steps.check-asset.outputs.skip == 'false' && !matrix.ephemeral && matrix.target_os == 'linux'
        continue-on-error: true
        shell: bash
        env:
          CACHE_ENDPOINT: ${{ secrets.CACHE_ENDPOINT }}
          CACHE_ACCESS_KEY: ${{ secrets.CACHE_ACCESS_KEY }}
          CACHE_SECRET_KEY: ${{ secrets.CACHE_SECRET_KEY }}
          UPSTREAM_VERSION: ${{ needs.prepare.outputs.upstream_version }}
        run: |
          set -euo pipefail
          BUILD_DIR="$CHROMIUM_SRC/out/Cloakium-${{ matrix.target }}"

          # Skip if build output already exists (subsequent runs)
          if [ -d "$BUILD_DIR" ] && [ -f "$BUILD_DIR/build.ninja" ]; then
            echo "Build output already exists at $BUILD_DIR — skipping seed"
            exit 0
          fi

          # Need MinIO credentials to pull
          if [ -z "${CACHE_ENDPOINT:-}" ]; then
            echo "No CACHE_ENDPOINT — full build will be required"
            exit 0
          fi

          CACHE_KEY="build-cache/${{ matrix.target }}/$UPSTREAM_VERSION"
          echo "Seeding build output from MinIO: $CACHE_KEY"

          # Configure mc if not already configured
          if ! mc alias ls cache &>/dev/null; then
            mc alias set cache "$CACHE_ENDPOINT" "$CACHE_ACCESS_KEY" "$CACHE_SECRET_KEY"
          fi

          # Check if cache exists
          if ! mc stat "cache/cloakium-cache/$CACHE_KEY/build-output.tar.zst" &>/dev/null; then
            echo "No cached build output found at $CACHE_KEY — full build will be required"
            exit 0
          fi

          echo "Downloading and extracting build output..."
          mc cat "cache/cloakium-cache/$CACHE_KEY/build-output.tar.zst" \
            | zstd -d -T0 \
            | tar -xf - -C "$CHROMIUM_SRC"

          if [ -d "$BUILD_DIR" ]; then
            echo "Seed complete. Build output at: $BUILD_DIR"
            ls -la "$BUILD_DIR/" | head -20
          else
            echo "Extraction completed but $BUILD_DIR not found — full build will be required"
          fi

      # --- Common steps (continued) ---

      - name: Install sysroot (cross-compile)
        if: steps.check-asset.outputs.skip == 'false' && matrix.cross && matrix.target_os == 'linux'
        shell: bash
        run: |
          cd "$CHROMIUM_SRC"
          python3 build/linux/sysroot_scripts/install-sysroot.py --arch=${{ matrix.target_cpu }}

      - name: Apply patches
        if: steps.check-asset.outputs.skip == 'false'
        shell: bash
        run: |
          set -euo pipefail
          cd "$CHROMIUM_SRC"

          # Hard reset to guarantee clean tree (including v8 subdir managed by gclient)
          git reset --hard HEAD
          git clean -fd 2>/dev/null || true
          if [ -d v8 ] && git -C v8 rev-parse --git-dir &>/dev/null; then
            git -C v8 checkout -- . 2>/dev/null || true
          fi

          # Phase 1: Inject required #include headers (version-independent).
          ensure_include() {
            local file="$1" header="$2"
            if ! grep -qF "$header" "$file"; then
              local last
              last="$(grep -n '^#include' "$file" | tail -1 | cut -d: -f1)"
              sed -i.bak "${last}a\\
          ${header}" "$file"
              rm -f "$file.bak"
              echo "  Injected $header into $(basename "$file")"
            fi
          }

          for f in \
            third_party/blink/renderer/core/frame/navigator.cc \
            third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc \
            third_party/blink/renderer/modules/webaudio/realtime_analyser.cc \
            third_party/blink/renderer/core/dom/element.cc \
            third_party/blink/renderer/core/frame/navigator_concurrent_hardware.cc; do
            [ -f "$f" ] && ensure_include "$f" '#include "base/command_line.h"'
          done
          for f in \
            third_party/blink/renderer/modules/webaudio/realtime_analyser.cc \
            third_party/blink/renderer/core/dom/element.cc \
            third_party/blink/renderer/core/frame/navigator_concurrent_hardware.cc; do
            [ -f "$f" ] && ensure_include "$f" '#include "base/strings/string_number_conversions.h"'
          done

          # Phase 2: Apply patches. For each, try patch(1) first; on failure
          # check if the functional change is already present.
          check_applied() {
            case "$1" in
              01-*) grep -q 'kFingerprint\[\]' content/public/common/content_switches.cc ;;
              02-*) grep -q 'fingerprint-platform' third_party/blink/renderer/core/execution_context/navigator_base.cc ;;
              03-*) grep -q 'HeadlessChrome' components/embedder_support/user_agent_utils.cc && return 1; return 0 ;;
              04-*) grep -q 'cdc_adoQpoasnfa76pfcZLmcfl' chrome/test/chromedriver/chrome/devtools_client_impl.cc && return 1; return 0 ;;
              05-*) grep -q 'fingerprint-hardware-concurrency' third_party/blink/renderer/core/frame/navigator_concurrent_hardware.cc ;;
              06-*) grep -q 'fingerprint-gpu-renderer' third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc ;;
              07-*) grep -q 'Stealth: add per-session noise' third_party/blink/renderer/modules/canvas/canvas2d/base_rendering_context_2d.cc ;;
              08-*) grep -q 'Stealth: add per-session noise to audio' third_party/blink/renderer/modules/webaudio/realtime_analyser.cc ;;
              09-*) grep -q 'Stealth: add per-session noise to client rects' third_party/blink/renderer/core/dom/element.cc ;;
              10-*) grep -q 'window.chrome' chrome/renderer/chrome_content_renderer_client.cc ;;
              11-*) grep -q 'Stealth: always report PDF' third_party/blink/renderer/modules/plugins/dom_plugin_array.cc ;;
              12-*) grep -q 'ShouldSuppressAutomationInfoBar' chrome/browser/ui/startup/automation_infobar_delegate.cc ;;
              14-*) grep -q 'fingerprint' content/browser/renderer_host/render_process_host_impl.cc ;;
              15-*) grep -q 'fingerprint-platform' components/embedder_support/user_agent_utils.cc ;;
              24-*) grep -q 'console_delegate' v8/src/execution/messages.cc ;;
              25-*) grep -q 'hasUserStackGetter' v8/src/inspector/value-mirror.cc ;;
              *) return 1 ;;
            esac
          }

          needs_fallback=()
          for patchfile in "$GITHUB_WORKSPACE/patches/"*.patch; do
            name="$(basename "$patchfile")"
            echo "Applying: $name"
            if patch -p1 --fuzz=3 --no-backup-if-mismatch --forward < "$patchfile" 2>&1; then
              echo "  OK: $name"
            else
              find . -name '*.rej' -delete 2>/dev/null
              if check_applied "$name"; then
                echo "  OK (already present): $name"
                # Collect patched files so we can touch them to force recompilation
                grep -E '^\+\+\+ [ab]/' "$patchfile" | sed 's|^+++ [ab]/||' >> /tmp/_patch_files.txt 2>/dev/null || true
              else
                needs_fallback+=("$name")
                echo "  DEFERRED to fallback: $name"
              fi
            fi
          done

          # Touch files from "already present" patches to ensure ninja recompiles them
          if [ -f /tmp/_patch_files.txt ]; then
            sort -u /tmp/_patch_files.txt | while read -r f; do
              if [ -f "$f" ]; then
                touch "$f"
                echo "  Touched: $f"
              fi
            done
            rm -f /tmp/_patch_files.txt
          fi

          # Phase 3: Version-independent fallback injection via Python.
          if [ ${#needs_fallback[@]} -gt 0 ]; then
            echo "=== Phase 3: Fallback injection for ${#needs_fallback[@]} patch(es) ==="
            python3 "$GITHUB_WORKSPACE/scripts/fallback_inject.py" "${needs_fallback[@]}"
          fi

          echo "All patches applied."

      - name: Generate build config
        if: steps.check-asset.outputs.skip == 'false'
        shell: bash
        env:
          TARGET_OS: ${{ matrix.target_os }}
          TARGET_CPU: ${{ matrix.target_cpu }}
        run: |
          set -euo pipefail
          cd "$CHROMIUM_SRC"
          BUILD_DIR="out/Cloakium-${{ matrix.target }}"
          mkdir -p "$BUILD_DIR"

          # Base args common to all targets
          cat > "$BUILD_DIR/args.gn" << GNEOF
          is_debug = false
          is_official_build = true
          symbol_level = 0
          blink_symbol_level = 0
          enable_nacl = false
          is_component_build = false
          proprietary_codecs = true
          ffmpeg_branding = "Chrome"
          target_cpu = "$TARGET_CPU"
          GNEOF

          # macOS: use Xcode 16.2 SDK + disable Metal (host lacks Metal toolchain)
          if [ "$TARGET_OS" = "mac" ]; then
            SDK_PATH="/Applications/Xcode-16.2.0.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.2.sdk"
            if [ -d "$SDK_PATH" ]; then
              echo "mac_sdk_path = \"$SDK_PATH\"" >> "$BUILD_DIR/args.gn"
            fi
            echo 'angle_enable_metal = false' >> "$BUILD_DIR/args.gn"
          fi

          echo "=== args.gn ==="
          cat "$BUILD_DIR/args.gn"

          gn gen "$BUILD_DIR"

      - name: Build
        if: steps.check-asset.outputs.skip == 'false'
        shell: bash
        run: |
          set -euo pipefail
          cd "$CHROMIUM_SRC"
          BUILD_DIR="out/Cloakium-${{ matrix.target }}"

          autoninja -C "$BUILD_DIR" chrome

      # --- Ephemeral-only: upload build cache to MinIO ---

      - name: Upload build cache to MinIO
        if: steps.check-asset.outputs.skip == 'false' && matrix.ephemeral && env.CACHE_OK == 'true'
        continue-on-error: true
        shell: bash
        env:
          CACHE_ENDPOINT: ${{ secrets.CACHE_ENDPOINT }}
          CACHE_ACCESS_KEY: ${{ secrets.CACHE_ACCESS_KEY }}
          CACHE_SECRET_KEY: ${{ secrets.CACHE_SECRET_KEY }}
          UPSTREAM_VERSION: ${{ needs.prepare.outputs.upstream_version }}
        run: |
          set -euo pipefail
          cd "$CHROMIUM_SRC"
          BUILD_DIR="out/Cloakium-${{ matrix.target }}"
          CACHE_KEY="build-cache/${{ matrix.target }}/$UPSTREAM_VERSION"

          # Reconfigure mc (clean runner step)
          mc alias set cache "$CACHE_ENDPOINT" "$CACHE_ACCESS_KEY" "$CACHE_SECRET_KEY"

          echo "Uploading build cache: $BUILD_DIR → $CACHE_KEY"
          echo "Build dir size: $(du -sh "$BUILD_DIR" | cut -f1)"

          # Stream tar+zstd directly to MinIO (no temp file needed)
          tar -C "$CHROMIUM_SRC" -cf - "$BUILD_DIR" \
            | zstd -T0 -1 \
            | mc pipe "cache/cloakium-cache/$CACHE_KEY/build-output.tar.zst"

          # Also save the args.gn and build metadata
          mc cp "$BUILD_DIR/args.gn" "cache/cloakium-cache/$CACHE_KEY/args.gn"
          echo "$UPSTREAM_VERSION" | mc pipe "cache/cloakium-cache/$CACHE_KEY/version.txt"

          echo "Cache uploaded to: $CACHE_KEY"

          # List what we uploaded
          mc ls "cache/cloakium-cache/$CACHE_KEY/"

      # --- Common steps (continued) ---

      - name: Smoke test
        if: steps.check-asset.outputs.skip == 'false'
        shell: bash
        env:
          TARGET_OS: ${{ matrix.target_os }}
        run: |
          set -euo pipefail
          cd "$CHROMIUM_SRC"
          BUILD_DIR="out/Cloakium-${{ matrix.target }}"

          # Only run smoke test for native builds (not cross-compiled)
          if [ "${{ matrix.cross }}" = "true" ]; then
            echo "Cross-compiled build — skipping smoke test"
            exit 0
          fi

          case "$TARGET_OS" in
            linux)
              "$BUILD_DIR/chrome" --headless --disable-gpu --no-sandbox \
                --dump-dom "data:text/html,<h1>smoke</h1>" 2>/dev/null | grep -q smoke
              echo "Smoke test passed"
              ;;
            mac)
              "$BUILD_DIR/Chromium.app/Contents/MacOS/Chromium" --headless --disable-gpu \
                --dump-dom "data:text/html,<h1>smoke</h1>" 2>/dev/null | grep -q smoke
              echo "Smoke test passed"
              ;;
            *)
              echo "No native smoke test for $TARGET_OS"
              ;;
          esac

      - name: Package artifact
        if: steps.check-asset.outputs.skip == 'false'
        shell: bash
        env:
          TARGET_OS: ${{ matrix.target_os }}
          ASSET_NAME: ${{ matrix.asset }}
        run: |
          set -euo pipefail
          cd "$CHROMIUM_SRC"
          BUILD_DIR="out/Cloakium-${{ matrix.target }}"
          DIST="$GITHUB_WORKSPACE/dist"
          mkdir -p "$DIST"

          case "$TARGET_OS" in
            linux)
              # Package chrome binary + supporting files
              cd "$BUILD_DIR"
              find . -maxdepth 1 \( \
                -name "chrome" -o -name "chrome_sandbox" -o \
                -name "chrome_crashpad_handler" -o \
                -name "*.pak" -o -name "*.bin" -o -name "*.dat" -o \
                -name "*.so" -o -name "*.so.*" \
              \) -o -type d \( \
                -name "locales" -o -name "swiftshader" \
              \) | sort > /tmp/pkg-list.txt
              tar -cf - -T /tmp/pkg-list.txt | zstd -T0 -19 > "$DIST/$ASSET_NAME"
              cd "$CHROMIUM_SRC"
              ;;
            mac)
              # Package the .app bundle
              cd "$BUILD_DIR"
              zip -qr "$DIST/$ASSET_NAME" Chromium.app/
              ;;
          esac

          echo "Packaged: $DIST/$ASSET_NAME ($(du -h "$DIST/$ASSET_NAME" | cut -f1))"

      - name: Upload asset to GitHub Release
        if: steps.check-asset.outputs.skip == 'false'
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          tag="${{ needs.prepare.outputs.tag }}"
          file="dist/${{ matrix.asset }}"
          gh release upload "$tag" "$file" \
            --repo "$GITHUB_REPOSITORY" \
            --clobber

  verify:
    needs: [prepare, build]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Verify all assets exist on the release
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          tag="${{ needs.prepare.outputs.tag }}"
          assets="$(gh release view "$tag" --repo "$GITHUB_REPOSITORY" --json assets -q '.assets[].name')"

          required=(
            "cloakium-linux-amd64.tar.zst"
            "cloakium-darwin-arm64.zip"
          )

          missing=0
          for a in "${required[@]}"; do
            if echo "$assets" | grep -qx "$a"; then
              echo "OK: $a"
            else
              echo "MISSING: $a"
              missing=1
            fi
          done

          if [ "$missing" -ne 0 ]; then
            echo "::error::Release $tag is incomplete."
            exit 1
          fi

          echo "Release $tag has all required assets."

      - name: Mark release as latest
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          tag="${{ needs.prepare.outputs.tag }}"
          gh release edit "$tag" --repo "$GITHUB_REPOSITORY" --latest
          echo "Release $tag marked as latest."

  stealth-test:
    needs: verify
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: linux-amd64
            runner: ubuntu-latest
            binary_name: chrome
          - platform: darwin-arm64
            runner: macos-latest
            binary_name: Chromium
    runs-on: ${{ matrix.runner }}
    timeout-minutes: 30

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install test dependencies
        run: |
          pip install pytest pytest-timeout playwright
          playwright install chromium
          playwright install-deps chromium

      - name: Install xvfb (Linux)
        if: runner.os == 'Linux'
        run: sudo apt-get update && sudo apt-get install -y xvfb

      - name: Download Cloakium binary
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          python3 scripts/download.py --platform ${{ matrix.platform }} --dest ./cloakium-bin

      - name: Resolve binary path
        run: |
          BINARY="$(find ./cloakium-bin -name "${{ matrix.binary_name }}" -type f | head -1)"
          if [ -z "$BINARY" ]; then
            echo "::error::Binary '${{ matrix.binary_name }}' not found in cloakium-bin/"
            exit 1
          fi
          chmod +x "$BINARY"
          if [ "$(uname -s)" = "Darwin" ]; then
            chmod -R +x ./cloakium-bin/
            xattr -cr ./cloakium-bin/
            APP_BUNDLE="$(find ./cloakium-bin -name '*.app' -type d | head -1)"
            if [ -n "$APP_BUNDLE" ]; then
              find "$APP_BUNDLE/Contents/Frameworks" \( -name "*.framework" -o -name "*.app" -o -name "*.dylib" \) -print0 \
                | xargs -0 -I{} codesign --sign - --force "{}" 2>&1 || true
              codesign --sign - --force "$APP_BUNDLE" 2>&1 || true
            fi
          fi
          echo "STEALTH_BINARY=$BINARY" >> "$GITHUB_ENV"
          echo "Binary: $BINARY"

      - name: Run stealth tests
        env:
          STEALTH_BINARY: ${{ env.STEALTH_BINARY }}
        shell: bash
        run: |
          set -o pipefail
          mkdir -p reports
          if [ "$RUNNER_OS" = "Linux" ]; then
            HEADFUL=1 EXTRA_STEALTH_ARGS="--enable-unsafe-swiftshader --ignore-gpu-blocklist --disable-gpu-driver-bug-workarounds" \
              xvfb-run --auto-servernum --server-args="-screen 0 1920x1080x24" \
              pytest tests/test_stealth.py::TestWebDriverDetection \
              -v --tb=short \
              --junitxml=reports/results-${{ matrix.platform }}.xml \
              2>&1 | tee reports/test-output.txt
          else
            pytest tests/test_stealth.py::TestWebDriverDetection \
              -v --tb=short \
              --junitxml=reports/results-${{ matrix.platform }}.xml \
              2>&1 | tee reports/test-output.txt
          fi

      - name: Run live detection site tests
        continue-on-error: true
        env:
          STEALTH_BINARY: ${{ env.STEALTH_BINARY }}
        shell: bash
        run: |
          set -o pipefail
          mkdir -p reports
          if [ "$RUNNER_OS" = "Linux" ]; then
            HEADFUL=1 EXTRA_STEALTH_ARGS="--enable-unsafe-swiftshader --ignore-gpu-blocklist --disable-gpu-driver-bug-workarounds" \
              xvfb-run --auto-servernum --server-args="-screen 0 1920x1080x24" \
              pytest tests/test_stealth.py::TestBotDetectionSites \
              -v --tb=short -m slow --timeout=60 \
              --junitxml=reports/results-live-${{ matrix.platform }}.xml \
              2>&1 | tee -a reports/test-output.txt
          else
            pytest tests/test_stealth.py::TestBotDetectionSites \
              -v --tb=short -m slow --timeout=60 \
              --junitxml=reports/results-live-${{ matrix.platform }}.xml \
              2>&1 | tee -a reports/test-output.txt
          fi

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: results-${{ matrix.platform }}
          path: |
            reports/results-${{ matrix.platform }}.xml
            reports/results-live-${{ matrix.platform }}.xml

  stealth-report:
    needs: stealth-test
    if: always()
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Download all test results
        uses: actions/download-artifact@v4
        with:
          path: reports
          merge-multiple: true

      - name: Generate combined report
        run: |
          python3 - <<'PYEOF'
          import xml.etree.ElementTree as ET
          import datetime, glob, os

          timestamp = datetime.datetime.now(datetime.timezone.utc).strftime("%Y-%m-%d %H:%M UTC")
          lines = [
              "# Stealth Test Report",
              "",
              f"**Date:** {timestamp}",
              "",
          ]

          xml_files = sorted(glob.glob("reports/results-*.xml"))
          if not xml_files:
              lines.append("No test results found.")
              with open("reports/stealth-test-latest.md", "w") as f:
                  f.write("\n".join(lines))
              raise SystemExit(0)

          grand_passed = grand_total = 0
          grand_time = 0.0

          for xml_path in xml_files:
              platform = os.path.basename(xml_path).replace("results-", "").replace(".xml", "")
              tree = ET.parse(xml_path)
              root = tree.getroot()
              suite = root.find("testsuite") if root.tag != "testsuite" else root

              tests = int(suite.get("tests", 0))
              failures = int(suite.get("failures", 0))
              errors = int(suite.get("errors", 0))
              skipped = int(suite.get("skipped", 0))
              suite_time = float(suite.get("time", 0))
              passed = tests - failures - errors - skipped

              grand_passed += passed
              grand_total += tests
              grand_time += suite_time

              lines.append(f"## {platform}")
              lines.append("")
              lines.append(f"**Result:** {passed}/{tests} passed in {suite_time:.1f}s")
              lines.append("")
              lines.append("| Test | Status | Time |")
              lines.append("|------|--------|------|")

              for tc in suite.iter("testcase"):
                  name = tc.get("name", "unknown")
                  tc_time = float(tc.get("time", 0))
                  failure = tc.find("failure")
                  error = tc.find("error")
                  skip = tc.find("skipped")
                  if failure is not None:
                      status = "FAIL"
                  elif error is not None:
                      status = "ERROR"
                  elif skip is not None:
                      status = "SKIP"
                  else:
                      status = "PASS"
                  lines.append(f"| `{name}` | {status} | {tc_time:.2f}s |")

              lines.append("")

          lines.append(f"**Total: {grand_passed}/{grand_total} passed across {len(xml_files)} platform(s) in {grand_time:.1f}s**")
          lines.append("")

          with open("reports/stealth-test-latest.md", "w") as f:
              f.write("\n".join(lines))
          print(f"Report: {grand_passed}/{grand_total} passed in {grand_time:.1f}s")
          PYEOF

      - name: Commit report
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          # Stash downloaded artifacts so pull --rebase can work
          git stash --include-untracked
          git pull --rebase
          git stash pop || true
          git add reports/stealth-test-latest.md
          if git diff --cached --quiet; then
            echo "No changes to commit"
          else
            git commit -m "test: update stealth test report"
            git push
          fi
